

<!doctype html>


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. Building our first plugin &#8212; gvsig 0 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/bizstyle.js"></script>
    <link rel="shortcut icon" href="../../../_static/gvSIG.ico"/>
    <link rel="top" title="gvsig 0 documentation" href="../../../index.html" />
    <link rel="up" title="Documentación de gvSIG (ES)" href="../../index.html" />
    <link rel="next" title="6. Conclusiones" href="conclusions.html" />
    <link rel="prev" title="4. Herramientas de construcción" href="build_tools.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="conclusions.html" title="6. Conclusiones"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="build_tools.html" title="4. Herramientas de construcción"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">gvSIG Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Documentación de gvSIG (ES)</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/gvsig_asoc.jpg" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. Building our first plugin</a><ul>
<li><a class="reference internal" href="#planteamiento">5.1. Planteamiento</a></li>
<li><a class="reference internal" href="#nuestro-primer-proyecto">5.2. Nuestro primer proyecto</a></li>
<li><a class="reference internal" href="#trabajando-con-un-ide-netbeans">5.3. Trabajando con un IDE, Netbeans</a></li>
<li><a class="reference internal" href="#estructura-de-un-proyecto">5.4. Estructura de un proyecto</a></li>
<li><a class="reference internal" href="#las-dependencias-en-los-distintos-proyectos">5.5. Las dependencias en los distintos proyectos</a></li>
<li><a class="reference internal" href="#la-libreria-con-la-logica">5.6. La librería con la lógica</a></li>
<li><a class="reference internal" href="#la-libreria-con-la-presentacion">5.7. La librería con la presentación</a></li>
<li><a class="reference internal" href="#integrandolo-con-gvsig">5.8. Integrándolo con gvSIG</a></li>
<li><a class="reference internal" href="#distribuyendo-nuestro-proyecto">5.9. Distribuyendo nuestro proyecto</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="build_tools.html"
                        title="previous chapter">4. Herramientas de construcción</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="conclusions.html"
                        title="next chapter">6. Conclusiones</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/es/developers_quick_start/2.2/building_our_first_plugin.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div> 
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="building-our-first-plugin">
<h1>5. Building our first plugin<a class="headerlink" href="#building-our-first-plugin" title="Permalink to this headline">¶</a></h1>
<div class="section" id="planteamiento">
<h2>5.1. Planteamiento<a class="headerlink" href="#planteamiento" title="Permalink to this headline">¶</a></h2>
<p>Llegados aquí vamos a ver un projecto de ejemplo que nos permita ver
una serie de funcionalidades básicas de gvSIG.Los requerimientos podrían ser:</p>
<ul class="simple">
<li>Que nos permita ver la cartografía de manzanas</li>
<li>Que disponga de una herramienta de consulta que al pinchar sobre
una manzana nos muestre la información de las parcelas catastrales
asociadas a ella.</li>
<li>Que personalice el <em>splash</em> de gvSIG, así como el fondo de la ventana
principal de gvSIG con la imagen corporativa.</li>
<li>Al arrancar gvSIG presentará una ventana con el mapa directamente,
sin que el usuario deba interactuar con la aplicación para ello,
y estará activada la herramienta de información catastral.</li>
<li>Se personalizará el &#8220;acerca de&#8221; de gvSIG para introducir la información
corporativa.</li>
<li>Se deshabilitarán las herramientas de edición sobre el mapa de manzanas.</li>
<li>Se preparará un paquete de instalación con el plugin para que los usuarios
puedan instalarlo mediante el administrador de complementos de la aplicación.</li>
</ul>
<p>Para empezar a realizar nuestro proyecto utilizaremos el asistente para la generación
de proyectos que se incluye en la distribución de gvSIG.</p>
</div>
<div class="section" id="nuestro-primer-proyecto">
<h2>5.2. Nuestro primer proyecto<a class="headerlink" href="#nuestro-primer-proyecto" title="Permalink to this headline">¶</a></h2>
<p>Para gvSIG 2.2 disppone de un proyecto <em>base</em> que usar para la creacion de sus proyectos,
y que nos va a permitir disponer de un ejemplo para las principales formas de interaccionar
con gvSIG, y que normalmente usaremos como plantilla para crear nuestros proyectos.</p>
<p>Este proyecto podemos encontrarlo en el svn de gvsig, en la url:</p>
<p><a class="reference external" href="http://devel.gvsig.org/svn/gvsig-plugintemplates/org.gvsig.landregistryviewer/trunk/org.gvsig.landregistryviewer/">http://devel.gvsig.org/svn/gvsig-plugintemplates/org.gvsig.landregistryviewer/trunk/org.gvsig.landregistryviewer/</a></p>
<p>Antes de empezar, deberemos realizar unas pocas tareas de configuracion:</p>
<ul class="simple">
<li>Disponer de un JDK 1.7 instalado y accesible en el PATH.</li>
<li>Disponer de cliente de svn accesible en el PATH.</li>
<li>Disponer de maven accesible en el PATH.</li>
<li>Configurar donde se encuetra la instalacion de gvSIG sobre la que vamos a trabajar.</li>
</ul>
<p>Suponiendo que ya estan instalados y configurados el JDK, el cliente de svn, y maven, vamos
a ver como configurar donde se encuentra la instalacion de gvSIG que vamos a usar.</p>
<p>En el HOME de nuestro usuario deberemos tener un fichero <strong>.gvsig-devel.properties</strong>. Se trata de un
fichero properties standard de java. En el debera haber una entrada de clave <strong>gvsig.product.folder.path</strong>
que indicara el path donde esta la instalacion de gvSIG.</p>
<p>Deberemos tener especial cuidado de que tengamos permisos de escritura en la carpeta de la instalacion
de gvSIG que vayamos a utilizar ya que de lo contrario se produciran error en el despliegue de nuestro
plugin.</p>
<p>Procederemos a ejecutar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>~ $ cd $HOME/devel
~ $ svn checkout http://devel.gvsig.org/svn/gvsig-plugintemplates/org.gvsig.landregistryviewer/trunk/org.gvsig.landregistryviewer/
...salida del comando svn...
~ $ cd org.gvsig.landregistryviewer
~ $ mvn install
... salida del comando install...
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Si estamos utilizando MS Windows deberemos tener especial cuidado con algunos detalles:</p>
<ul class="last">
<li><p class="first">Podemos tener problemas con el tamaño de las rutas, en gvSIG se utilizan rutas muy largas.
Es recomendable que cree una carpeta en el raiz de la unidad, por ejemplo <strong>C:/devel</strong> y
usar esta para trabajar sobre ella.</p>
</li>
<li><p class="first">Normalmente la instalacion de gvSIG se realizara en modo administrador, y nuestro usuario no dispondra
de permisos para sobreescribir archivos y carpetas de esta, ademas de que puede contener rutas con
<em>espacios</em>  que puede ocasionarnos problemas de despliegue de nuestros plugins.
Para evitar problemas la sugerencia es que creemos la carpeta  <em>C:/devel/gvSIG-desktop</em> y copiemos
en ella la instalacion de gvSIG.</p>
</li>
<li><p class="first">A la hora de crear el fichero <em>.gvsig-devel,properties</em> podemos tener algun problema. Deberemos
crearlo en el HOME de nuestro usuario, normalmente <em>C:/Usuario/mi-usuario</em>. Y tener especial
precaucion con:</p>
<ul>
<li><dl class="first docutils">
<dt>el fichero debe llamarse exactamente &#8221;.gvsig-devel.properties&#8221;, sin extension &#8221;.txt&#8221;, asegurese</dt>
<dd><p class="first last">de que al crearlo no tiene extension &#8221;.txt&#8221;.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Puede tener problemas para crear un fichero que comienze por &#8221;.&#8221;. Una forma de hacerlo puede ser</dt>
<dd><p class="first last">abrir el bloc de notas y guardar el fichero en la ruta y nombre indicado.</p>
</dd>
</dl>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="trabajando-con-un-ide-netbeans">
<h2>5.3. Trabajando con un IDE, Netbeans<a class="headerlink" href="#trabajando-con-un-ide-netbeans" title="Permalink to this headline">¶</a></h2>
<p>Si estamos trabajando con un IDE como Netbeans podemos descargarnos el proyecto
de ejemplo con:</p>
<div class="figure align-center">
<img alt="../../../_images/netbeans-checkout-11.png" src="../../../_images/netbeans-checkout-11.png" />
</div>
<p>Que nos mostrara el cuadro de dialogo de descargar proyectos desde SVN.</p>
<div class="figure align-center">
<img alt="../../../_images/netbeans-checkout-21.png" src="../../../_images/netbeans-checkout-21.png" />
</div>
<p>Indicaremos en &#8220;Repository URL&#8221; el valor</p>
<blockquote>
<div><a class="reference external" href="http://devel.gvsig.org/svn/gvsig-plugintemplates/org.gvsig.landregistryviewer/trunk/org.gvsig.landregistryviewer/">http://devel.gvsig.org/svn/gvsig-plugintemplates/org.gvsig.landregistryviewer/trunk/org.gvsig.landregistryviewer/</a></div></blockquote>
<p>Despues nos pedira la carpeta donde queremos descargar el proyecto. Normalmente la dejaremos por defecto.</p>
<div class="figure align-center">
<img alt="../../../_images/netbeans-checkout-31.png" src="../../../_images/netbeans-checkout-31.png" />
</div>
<p>Una vez descargados los proyectos, nos informara que entre los archivos descargados hay varios proyectos de maven, y si queremos
cargar estos en el IDE. Pulsaremos en &#8220;Open projects...&#8221;</p>
<div class="figure align-center">
<img alt="../../../_images/netbeans-checkout-41.png" src="../../../_images/netbeans-checkout-41.png" />
</div>
<p>Nos mostrara los proyectos maven que ha encontrado. Seleccionaremos el primero y pulsaremos en &#8220;Open&#8221;</p>
<div class="figure align-center" id="id1">
<img alt="../../../_images/netbeans-checkout-51.png" src="../../../_images/netbeans-checkout-51.png" />
<p class="caption"><span class="caption-text">Una vez aqui ya nos mostrara en el arbol de proyectos el proyecto de ejemplo. Desplegando en &#8220;Modules&#8221; podemos ver la estructura de subproyectos o modulos de este.</span></p>
</div>
<div class="figure align-center">
<img alt="../../../_images/netbeans-checkout-61.png" src="../../../_images/netbeans-checkout-61.png" />
</div>
</div>
<div class="section" id="estructura-de-un-proyecto">
<h2>5.4. Estructura de un proyecto<a class="headerlink" href="#estructura-de-un-proyecto" title="Permalink to this headline">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Puede resultarle útil consultar la documentación existente
en la <em>Guía para desarrolladores</em> relacionada con esto, que
puede encontrar en la sección
<a class="reference external" href="https://gvsig.org/web/reference_catalog/lookupObject?uuid=1dad723b0c168999e622de9c6bf03017">Estructura de un proyecto en gvSIG</a> asi como en
<a class="reference external" href="https://gvsig.org/web/reference_catalog/lookupObject?uuid=eb91eb79e1e1f2ec730bfe13bb649f6c">Cosas a tener en cuenta antes de desarrollar un plugin</a> .</p>
</div>
<p>Vamos a echarle un vistazo al código del proyecto.
Los proyectos que encontraremos son:</p>
<ul class="simple">
<li><em>org.gvsig.landregistryviewer</em>. Se trata de un proyecto Maven con varios subproyectos. En ellos
encontraremos dividido, la parte de la lógica, con su API
e implementación, así como la parte de interface de usuario asociada a los componentes
de la lógica, también con su API e implementación, y un proyecto que nos permitirá
probar esa lógica e interfaces de usuario sin necesidad de arrancar gvSIG. En general
los distintos componentes que encontremos aquí serán independientes del framework
de Andami así como de los plugins de gvSIG, siendo dependientes únicamente de otras
librerías. Los proyectos que nos encontraremos serán:<ul>
<li><em>org.gvsig.landregistryviewer.lib</em> con la lógica de nuestro proyecto<ul>
<li><em>org.gvsig.landregistryviewer.lib.api</em></li>
<li><em>org.gvsig.landregistryviewer.lib.impl</em></li>
</ul>
</li>
<li><em>org.gvsig.landregistryviewer.swing</em> con el interface de usuario de nuestros
componentes lógicos.<ul>
<li><em>org.gvsig.landregistryviewer.swing.api</em></li>
<li><em>org.gvsig.landregistryviewer.swing.impl</em></li>
</ul>
</li>
<li><em>org.gvsig.landregistryviewer.main</em>, nuestra <em>main</em> de pruebas.</li>
<li><em>org.gvsig.landregistryviewer.app</em>. Este proyecto contendrá la implementación de los distintos plugins que
se van a añadir a gvSIG. Normalmente usará los componentes de los proyecto <em>org.gvsig.landregistryviewer.lib</em> y <em>org.gvsig.landregistryviewer.swing</em>, y se encargará de la integración de estos en gvSIG. En el ejemplo solo hay un subproyecto, <em>org.gvsig.landregistryviewer.app.mainplugin</em> ya que vamos a aportar un único plugin. Si tuviésemos necesidad de aportar más de un plugin tendríamos un subproyecto por plugin.</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>TODO:</p>
<p>Añadir el ejemplo de Chart como proyecto que aporta mas de un plugin.</p>
<p class="last">nota sobre balancear un solo plugin monolitico muchos pequeños.</p>
</div>
</div>
<div class="section" id="las-dependencias-en-los-distintos-proyectos">
<h2>5.5. Las dependencias en los distintos proyectos<a class="headerlink" href="#las-dependencias-en-los-distintos-proyectos" title="Permalink to this headline">¶</a></h2>
<p>A la hora de identificar un <em>artefacto</em> en maven, lo normal es que que intervengan al menos tres componentes, sin los cuales no es posible identificar al <em>artefacto</em>. Estos serian:</p>
<ul class="simple">
<li>Grupo, <strong>groupId</strong>. Normalmente hace referencia al nombre de nuestra organización.
Por ejemplo en gvSIG utilizamos <em>&#8220;org.gvsig&#8221;</em>, por otras organizaciones o empresas pueden
utilizar uno propio.</li>
<li>Identificador, <strong>artefactId</strong>. Deber ser un identificador del proyecto único dentro del
grupo.</li>
<li>Versión, <strong>version</strong>. En el proceso de desarrollo iremos generando distintas revisiones o versiones
de nuestros productos o <em>artefactos</em>. Para identificarlos no solo deberemos indicar su nombre,
si no también la versión a la que nos referimos.</li>
</ul>
<p>Todo proyecto maven deberá identificarse por estos tres datos. Así en el <em>pom.xml</em> del raíz de nuestro
proyecto encontraremos algo como:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>org.gvsig
org.gvsig.landregistryviewer
1.0.0-SNAPSHOT
</pre></div>
</div>
<p>Donde se declaran esos valores.</p>
<p>Además en el <em>pom</em> de nuestro proyecto raíz también encontraremos:</p>
<ul>
<li><p class="first">Una declaración de quien es el padre o de quien extiende nuestro proyecto, sección <strong>parent</strong>:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>org.gvsig
org.gvsig.desktop
2.0.100
</pre></div>
</div>
<p>Aquí observaremos que, normalmente, en un proyecto gvSIG, extenderemos o heredaremos del proyecto <em>org.gvsig:org.gvsig.desktop</em>.
Este proyecto tiene la configuración necesaria para compilar y desplegar proyectos gvSIG, normalmente plugins para la aplicacion
<em>gvSIG desktop</em> y las librerias que estos precisen. Además de la configuración básica, también tiene declarada la versión de
todos los componentes que forman el núcleo de gvSIG, de forma que no tengamos que declararla cada vez que indiquemos una dependencia
con un subproyecto del núcleo.</p>
</li>
<li><p class="first">Una sección donde declararemos las versiones de los subproyectos que conforman nuestro
proyecto. En maven esto lo realizaremos en la sección <strong>dependencyManagement</strong>. Normalmente aquí
especificaremos:</p>
<ul class="simple">
<li>Declararemos todos los subproyectos de nuestro proyecto.</li>
<li>Declararemos las dependencias con los proyecto o artefactos que no formen parte del
núcleo de gvSIG, como otras librerías que podamos necesitar.</li>
</ul>
<p>Hay que tener en cuenta que en esta sección, <strong>dependencyManagement</strong>, indicamos que versiones de que artefactos queremos usar cuando especifiquemos una dependencia con estos en la sección <strong>dependencies</strong>. Que aparezca una depedencia en  <strong>dependencyManagement</strong> no le esta indicando a <em>maven</em> que exista una dependencia real con ese artefacto, esto solo sucederá con las que se incluyan en la sección <strong>dependencies</strong>.</p>
<p>Para nuestro caso tendríamos algo como:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>org.gvsig
org.gvsig.landregistryviewer.lib.api
1.0.0-SNAPSHOT


org.gvsig
org.gvsig.landregistryviewer.lib.api
1.0.0-SNAPSHOT
test-jar


org.gvsig
org.gvsig.landregistryviewer.lib.impl
1.0.0-SNAPSHOT


org.gvsig
org.gvsig.landregistryviewer.swing.api
1.0.0-SNAPSHOT


org.gvsig
org.gvsig.landregistryviewer.swing.api
1.0.0-SNAPSHOT
test-jar


org.gvsig
org.gvsig.landregistryviewer.swing.impl
1.0.0-SNAPSHOT


org.gvsig
org.gvsig.landregistryviewer.app.mainplugin
1.0.0-SNAPSHOT
</pre></div>
</div>
<p>Muy importante que las versiones de los subproyectos aquí indicadas coincidan siempre con la versión del proyecto raíz.</p>
<p>La finalidad principal sera centralizar en este <em>pom</em> la declaración de las versiones de las
dependencias de nuestro proyecto de cara a facilitar su mantenimiento.</p>
<p>Si dependediesemos de algún otro proyecto de gvSIG, normalmente lo que haremos seria importar las
dependencias que este tuviese declaradas en su <em>dependencyManagement</em> en lugar de ir declarando una
a una las que precisemos. Esto reduce la posibilidad de confusión al declarar las dependencias
de estos. Así por ejemplo si quisiésemos declarar las versiones de los subproyectos base de raster
pondríamos algo como:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>      org.gvsig
      org.gvsig.raster
      ${org.gvsig.raster.version}
      pom
      import


      org.gvsig
      org.gvsig.landregistryviewer.lib.api
      1.0.0-SNAPSHOT

...
</pre></div>
</div>
<p>Y declararíamos la propiedad <em>&#8220;org.gvsig.raster.version&#8221;</em> en la sección <em>properties</em>:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>2.2.16
</pre></div>
</div>
<p>Podemos o no usar un <em>property</em> para indicar la versión del proyecto del cual importamos las dependencias.
La ventaja de usar un <em>property</em> es que podemos actualizar nuestro proyecto fácilmente a la ultima revisión
de gvSIG con:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mvn</span> <span class="n">versions</span><span class="p">:</span><span class="n">update</span><span class="o">-</span><span class="n">parent</span>  <span class="n">versions</span><span class="p">:</span><span class="n">update</span><span class="o">-</span><span class="n">properties</span>
</pre></div>
</div>
<p>Pero antes de ejecutar esto es conveniente informarse de si se ha generado ya alguna versión de desarrollo
para la siguiente versión a la ultima <em>&#8220;final&#8221;</em> liberada.</p>
</li>
</ul>
<p>Una cuestión mas a tener en cuenta relacionada con las versiones de los artefactos que podemos encontrar en
el <em>&#8220;pom&#8221;</em> es que estas no se corresponden con las versiones de la aplicación &#8220;gvSIG desktop&#8221;. La aplicación
de usuario lleva su linea de versiones y cada uno de los artefactos de gvSIG la suya. Siendo así...</p>
<p>¿ Como podemos saber que versión de artefacto debemos usar ?</p>
<p>Para saber la versión de <em>org.gvsig.desktop</em> que debemos usar, deberemos decidir contra que versión de
la aplicación <em>gvSIG desktop</em> deberemos trabajar, y disponer de una versión de esta instalada.</p>
<p>Miraremos la versión del jar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">org</span><span class="o">.</span><span class="n">gvsig</span><span class="o">.</span><span class="n">andami</span><span class="o">-*.</span><span class="n">jar</span>
</pre></div>
</div>
<p>de dentro de la carpeta <em>&#8220;lib&#8221;</em> de la instalación de gvSIG. La versión de ese jar nos dirá la versión
que debemos usar como versión de <em>&#8220;org.gvsig.desktop&#8221;</em>.</p>
<p>Para <em>&#8220;gvSIG desktop 2.2.0-2313&#8221;</em> es <strong>2.0.100</strong>.</p>
<p>En el caso de la librería base de raster, org.gvsig.raster, en la carpeta
<em>lib</em> del plugin <em>org.gvsig.raster.mainplugin</em>, y podemos encontrar:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">org</span><span class="o">.</span><span class="n">gvsig</span><span class="o">.</span><span class="n">raster</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">api</span><span class="o">-*.</span><span class="n">jar</span>
</pre></div>
</div>
<p>del que podemos obtener la versión de esta. O si queremos enlazar con el plugin de <em>&#8220;mapas&#8221;</em>, consultaríamos
en el plugin <em>org.gvsig.app.document.layout2.app.mainplugin</em>, en la carpeta <em>lib</em> la versión de:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">org</span><span class="o">.</span><span class="n">gvsig</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">document</span><span class="o">.</span><span class="n">layout2</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">mainplugin</span><span class="o">-*.</span><span class="n">jar</span>
</pre></div>
</div>
<p>Las versiones de las dependencias mas comunes a usar podemos encontrarlas en:</p>
<table border="1" class="docutils" id="id2">
<caption><span class="caption-text">Registro de cambios</span><a class="headerlink" href="#id2" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Proyecto</th>
<th class="head">jar</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>org.gvsig.desktop</td>
<td>lib/org.gvsig.andami-...jar</td>
</tr>
<tr class="row-odd"><td>org.gvsig.raster</td>
<td>gvSIG/extensiones/org.gvsig.raster.mainplugin/lib/org.gvsig.raster.lib.api-...jar</td>
</tr>
<tr class="row-even"><td>org.gvsig.geoprocess</td>
<td>gvSIG/extensiones/org.gvsig.geoprocess.app.mainplugin/lib/org.gvsig.geoprocess.app.mainplugin-...jar</td>
</tr>
<tr class="row-odd"><td>org.gvsig.hyperlink.app</td>
<td>gvSIG/extensiones/org.gvsig.hyperlink.app.extension/lib/org.gvsig.hyperlink.app.extension-...jar</td>
</tr>
<tr class="row-even"><td>org.gvsig.mapsheets.app</td>
<td>gvSIG/extensiones/org.gvsig.mapsheets.app.mainplugin/lib/org.gvsig.mapsheets.app.mainplugin-...jar</td>
</tr>
<tr class="row-odd"><td>org.gvsig.vectorediting</td>
<td>gvSIG/extensiones/org.gvsig.vectorediting.app.mainplugin/lib/org.gvsig.vectorediting.app.mainplugin-...jar</td>
</tr>
<tr class="row-even"><td>org.gvsig.tools</td>
<td>lib/org.gvsig.tools.lib-...jar</td>
</tr>
</tbody>
</table>
<p>Además de la sección <strong>parent</strong> y <strong>dependencyManagement</strong>, en el <em>pom</em> podemos encontrarnos una sección <strong>dependencies</strong>.
Esta sección es donde se declaran las dependencias reales de nuestro proyecto, a partir de las que se construirá el
<em>classpath</em> de compilación y ejecución. Sin embargo recomendamos que en proyectos de tipo <em>pom</em>, como es el raíz,
no incluyamos ninguna dependencia, incluyéndolas únicamente en los proyectos <em>hoja</em>, de tipo <em>jar</em>, ya que
en un momento dado puede desvirtuarnos los informes de dependencias de nuestros proyectos.</p>
<p>Por ultimo, relacionado con el <em>pom</em> del proyecto raíz, es importante la sección <strong>modules</strong>, que indica cuales son
los subproyectos de este. Es importante tener en cuenta que una carpeta dentro del proyecto raíz no es un subproyecto
o modulo de este si no se declara aquí.</p>
<p>Vamos a comentar ahora sobre los demás <em>poms</em> que encontraremos en los distintos subproyectos.</p>
<p>Primero, sobre los <em>poms</em> de los subproyectos o módulos de tipo <em>pom</em>, que no son subproyectos <em>hoja</em>.
En estos lo mas importante es tener en cuenta que:</p>
<ul class="simple">
<li>Deberemos indicar siempre una sección <strong>parent</strong> en la que referenciaremos al pom padre
de este, utilizando su <strong>groupId</strong>, <strong>artifactId</strong> y <strong>version</strong>.</li>
<li>Incluiremos solo <strong>artifactId</strong>, ya que la <em>version</em> y <em>groupId</em> lo heredara del padre.</li>
<li>No incluiremos sección <strong>dependencies</strong>.</li>
<li>Incluiremos la sección <strong>modules</strong> con los subproyectos de este.</li>
</ul>
<p>Ahora pasemos a ver que tendremos en los <em>poms</em> de los proyectos <em>hoja</em>, de tipo <em>jar</em>.
Estos proyectos son los que generan <em>artefactos</em>, normalmente <em>jars</em> con nuestro código y
los que precisan que especifiquemos dependencias de cara a su correcta compilación. Asi
que sera en estos donde deberemos incluir la sección <strong>dependencies</strong>. A la hora de
especificar una dependencia tendremos que tener en cuenta que:</p>
<ul>
<li><p class="first">Siempre especificaremos su <strong>groupId</strong> y <strong>ArtefactId</strong>.</p>
</li>
<li><p class="first">No especificaremos nunca su <strong>version</strong>, esta deberemos haberla incluido
en el <strong>dependenciesManagement</strong> de nuestro proyecto raíz o vendrá heredada
del proyecto <em>org.gvsig.desktop</em>.</p>
</li>
<li><p class="first">Deberemos especificar siempre el <em>scope</em> de la dependencia. Aunque maven no
lo requiere siendo <em>compile</em> si no se especifica, desde el proyecto gvSIG
recomendamos que se incluya siempre de cara a evitar confusiones.</p>
<p>Normalmente el <strong>scope</strong> sera:</p>
<ul class="simple">
<li>compile</li>
<li>runtime</li>
</ul>
<p>Aunque hay algunos mas. Este nos indicara si esa dependencia debe incluirse en
el <em>classpath</em> de compilación o de ejecución.</p>
</li>
</ul>
<p>Vamos a comentar ahora algunas consideraciones sobre las dependencias entre los
distintos subproyectos. En gvSIG tendemos a separar <em>conceptos</em>, API/implementacion -
logica/GUI/plugin, influyendo esto directamente en la estructura de proyectos, ya que
como vimos anteriormente disponemos de un proyectos para la lógica (...lib) con su
API e implementación, otro proyecto para el interface de usuario (...swing), también
con su API e implementación, y otro para los plugins de gvSIG (...app).
Ahora bien... ¿ Que dependencias podemos encontrar en cada uno de ellos ?</p>
<p>Normalmente tendremos en cuenta una serie de reglas:</p>
<ul class="simple">
<li>La definición de APIs solo dependerá de proyectos que definan APIs.
Normalmente en los proyectos que definen APIs su <em>artifactId</em> termina en <em>&#8221;.api&#8221;</em>.</li>
<li>Nadie tendrá dependencias con proyectos que contengan la implementación de un API,
dependiendo estos exclusivamente de APIs.</li>
<li>En general, una librería, de API o implementación, nunca dependerá de una implementación,
un plugin de gvSIG a el framework de runtime de la aplicación gvSIG (andami).</li>
<li>Las librerías que contienen el interface de usuario, tanto su API como su implementación,
no deberán depender de la librería que implementa la lógica de ese interface de usuario,
solo de su API.</li>
<li>Solo los proyectos de tipo plugin de gvSIG podrán tener dependencias con otros plugins
o el framework de ejecución de gvSIG.</li>
</ul>
<p>Con esto en mente podemos echar un vistazo a las dependencias de los distintos <em>poms</em>
de nuestros proyectos.</p>
<ul>
<li><p class="first"><strong>org.gvsig.landregistryviewer.lib.api</strong>:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>org.gvsig
org.gvsig.tools.lib
compile


org.gvsig
org.gvsig.tools.lib
test-jar
test


org.gvsig
org.gvsig.fmap.geometry.api
compile


org.gvsig
org.gvsig.fmap.dal.api
compile
</pre></div>
</div>
<p>Depende de la librería <em>org.gvsig.tools.lib</em>, que contiene todas las utilidades básicas
para separación de API e implementación, con lo que prácticamente todos nuestros proyectos
dependerán de ella, y del API de las librerías de acceso a datos, <em>org.gvsig.fmap.dal.api</em>
y de manejo de geometrías, <em>org.gvsig.fmap.geometry.api</em>. Como se aprecia, solo depende
de APIs.</p>
</li>
<li><p class="first"><strong>org.gvsig.landregistryviewer.lib.impl</strong>, básicamente mantiene las mismas dependencias
que el API, pero además tiene dependencias de compilación con este.</p>
</li>
<li><p class="first"><strong>org.gvsig.landregistryviewer.swing.api</strong>:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>org.gvsig
org.gvsig.tools.lib
compile


org.gvsig
org.gvsig.tools.lib
test-jar
test


org.gvsig
org.gvsig.tools.swing.api
compile


  org.gvsig
  org.gvsig.landregistryviewer.lib.api
  compile
</pre></div>
</div>
<p>Dependerá del API de la parte de lógica, <em>org.gvsig.landregistryviewer.lib.api</em>, y además
del API de la parte de <em>swing</em> de la libreria org.gvsig.tools, <em>org.gvsig.tools.swing.api</em>.</p>
</li>
<li><p class="first"><strong>org.gvsig.landregistryviewer.swing.impl</strong>, dependerá básicamente de su API.</p>
</li>
<li><p class="first"><strong>org.gvsig.landregistryviewer.app.mainplugin</strong>, la parte del plugin para gvSIG desktop,
dependerá de:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>org.gvsig
org.gvsig.landregistryviewer.lib.api
compile


org.gvsig
org.gvsig.landregistryviewer.swing.api
compile



org.gvsig
org.gvsig.tools.lib
compile


org.gvsig
org.gvsig.tools.swing.api
compile



org.gvsig
org.gvsig.andami
compile


org.gvsig
org.gvsig.app.mainplugin
compile



org.gvsig
org.gvsig.fmap.control
compile


org.gvsig
org.gvsig.fmap.mapcontext.api
compile


org.gvsig
org.gvsig.fmap.geometry.api
compile


org.gvsig
org.gvsig.fmap.dal.api
compile


org.gvsig
org.gvsig.projection.api
compile



org.gvsig
org.gvsig.landregistryviewer.lib.impl
runtime


org.gvsig
org.gvsig.landregistryviewer.swing.impl
runtime
</pre></div>
</div>
<p>Como se trata del plugin para gvSIG, este depende específicamente del framework
de la aplicación gvSIG desktop, <em>org.gvsig.andami</em>, y del plugin principal de la aplicación,
<em>org.gvsig.app.mainplugin</em>. Además depende de algunas otras librerías de gvSIG, como:</p>
<ul class="simple">
<li>org.gvsig.fmap.control, componente gráfico para visualizar un mapa.</li>
<li>org.gvsig.fmap.mapcontext.api, la parte de lógica del componente del mapa.</li>
<li>org.gvsig.fmap.geometry.api, la librería de geometrías.</li>
<li>org.gvsig.fmap.dal.api, la librería de acceso a datos.</li>
<li>org.gvsig.projection.api, la librería de proyecciones.</li>
<li>org.gvsig.tools.lib.</li>
<li>org.gvsig.tools.swing.api.</li>
</ul>
<p>Además de depender para compilación de los APIs de las librerías del proyecto:</p>
<ul class="simple">
<li>org.gvsig.landregistryviewer.lib.api</li>
<li>org.gvsig.landregistryviewer.swing.api</li>
</ul>
<p>Y lo mas importante, deberá depender de las implementaciones de las librería del
proyecto en modo runtime.</p>
<ul class="simple">
<li>org.gvsig.landregistryviewer.lib.impl</li>
<li>org.gvsig.landregistryviewer.swing.impl</li>
</ul>
<p>Es importante esto por dos razones. Por un lado debe ser solo de runtime, si no significaría
que no hemos definido correctamente el API de nuestro proyecto, y por otro, es preciso que
se incluya la dependencia como de runtime ya que necesitaremos desplegarlas en nuestro
plugin y para ello es obligatorio que nuestro plugin dependa de ellas, como veremos mas
adelante cuando comentemos el código del plugin.</p>
</li>
</ul>
</div>
<div class="section" id="la-libreria-con-la-logica">
<h2>5.6. La librería con la lógica<a class="headerlink" href="#la-libreria-con-la-logica" title="Permalink to this headline">¶</a></h2>
<p>La parte de la lógica de nuestro desarrollo la encontraremos dividida en dos proyectos:</p>
<ul class="simple">
<li>org.gvsig.landregistryviewer.lib.api</li>
<li>org.gvsig.landregistryviewer.lib.impl</li>
</ul>
<p>En el proyecto del API encontraremos principalmente interfaces. Estos interfaces compondrán
el API de los componentes de lógica que precisemos desarrollar.
EL modelo de clases del ejemplo es el que se muestra en el siguiente diagrama:</p>
<div class="figure align-center" id="id3">
<img alt="../../../_images/org.gvsig.visor.api1.png" src="../../../_images/org.gvsig.visor.api1.png" />
<p class="caption"><span class="caption-text">Modelo de clases del API</span></p>
</div>
<p>Tendremos las siguientes entidades:</p>
<ul>
<li><p class="first"><strong>landregistryviewerLibrary</strong>, que representa al objeto <em>Library</em>. De esta clase señalar los métodos:</p>
<ul>
<li><p class="first"><em>doRegistration</em>, que se ejecuta al cargar la librería e informa qué clase de librería
es, en nuestro caso la definición de un API, así como qué otras librerías requiere que estén
inicializadas antes que esta, la librería de acceso a datos, y la de geometrías. El código
que hace esto es:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doRegistration</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">this</span><span class="o">.</span><span class="na">registerAs</span><span class="o">(</span><span class="n">landregistryviewerLibrary</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Library</span><span class="o">.</span><span class="na">TYPE</span><span class="o">.</span><span class="na">API</span><span class="o">);</span>
  <span class="k">this</span><span class="o">.</span><span class="na">require</span><span class="o">(</span><span class="n">DALLibrary</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="k">this</span><span class="o">.</span><span class="na">require</span><span class="o">(</span><span class="n">GeometryLibrary</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>doPostInitialize</em>, que se ejecuta cuando se han inicializado todas las librerías.
En nuestro caso realiza comprobaciones para verificar que al menos una implementación
del API ha sido registrada. El código que hace esto es:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doPostInitialize</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">LibraryException</span> <span class="o">{</span>
  <span class="c1">// Validate if there are any implementation registered.</span>
  <span class="n">landregistryviewerManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">landregistryviewerLocator</span><span class="o">.</span><span class="na">getManager</span><span class="o">();</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">manager</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">ReferenceNotRegisteredException</span><span class="o">(</span>
          <span class="n">landregistryviewerLocator</span><span class="o">.</span><span class="na">MANAGER_NAME</span><span class="o">,</span> <span class="n">landregistryviewerLocator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">()</span>
        <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first"><strong>landregistryviewerLocator</strong>, es el <em>locator</em> de nuestra librería, el encargado de
suministrarnos la instancia de nuestro manager. Se trata de una clase con métodos
estáticos para registrar implementaciones de este API u obtener una implementación
de él.</p>
</li>
<li><p class="first"><strong>landregistryviewerManager</strong>. Un interface. El del manager de la librería. Define métodos para obtener las
manzanas y parcelas así como para localizar una manzana dado un punto. Es la
entrada a las distintas entidades de nuestro modelo.</p>
</li>
<li><p class="first"><strong>landregistryviewerBlock</strong>. Un interface que representa a una manzana, y aporta métodos para obtener la geometría
que define la manzana o para obtener las parcelas que la constituyen.</p>
</li>
<li><p class="first"><strong>landregistryviewerProperty</strong>. Un interface que representa una parcela catastral. Tiene métodos para obtener
la geometría que la define, su código o municipio.</p>
</li>
</ul>
<p>Vamos a ver qué nos encontramos en la parte de implementación. Observaremos que
mientras que en el API lo normal ha sido encontrarnos interfaces, en la implementación
nos encontraremos clases. Clases que implementan los distintos interfaces que se
definieron en el API.  Por convenio, a la implementación de los distintos interfaces
que aparecen en el API las llamaremos igual que en el API anteponiéndole el prefijo <em>Default</em>.</p>
<p>El modelo de clases de la implementación para nuestro ejemplo es:</p>
<div class="figure align-center" id="id4">
<img alt="../../../_images/org.gvsig.visor.impl1.png" src="../../../_images/org.gvsig.visor.impl1.png" />
<p class="caption"><span class="caption-text">Modelo de clases de la implementación</span></p>
</div>
<p>Vamos a ir viendo las partes más relevantes de la implementación.</p>
<ul>
<li><p class="first"><strong>landregistryviewerDefaultImplLibrary</strong>. Al igual que en el API, esta clase se encarga de
inicializar la librería de la implementación. De esta clase señalar los métodos:</p>
<ul>
<li><p class="first"><em>doRegistration</em>, que se encarga de registrar la librería como una implementación
del API de <em>landregistryviewerLibrary</em>. Si tuviese otras dependencias distintas de las marcadas en el
API, se añadirían aquí para asegurarnos que esas librerías se inicializan antes
que esta, pero no es el caso de nuestro ejemplo. Al registrar esta librería como
una implementación de <em>landregistryviewerLibrary</em>, se cubren dos funciones. Por un lado la librería
del API será inicializada siempre antes que esta implementación, y por otro lado
cuando alguna otra librería fije dependencias con el API, el mecanismo de inicialización
de librerías se encargará de inicializar la implementación junto con el API para
asegurarnos de que dispondremos de una implementación del API que hemos requerido.
El código que necesitaremos poner en nuestro ejemplo será:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">doRegistration</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">this</span><span class="o">.</span><span class="na">registerAsImplementationOf</span><span class="o">(</span><span class="n">landregistryviewerLibrary</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>doInitialize</em>, que se encarga de registrar en el locator del API la implementación
del manager que tenemos en esta librería. El código que hace esto es:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doInitialize</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">LibraryException</span> <span class="o">{</span>
    <span class="n">VisorLocator</span><span class="o">.</span><span class="na">registerManager</span><span class="o">(</span><span class="n">DefaultlandregistryviewerManager</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first"><strong>DefaultlandregistryviewerManager</strong>. De esta clase conviene resaltar principalmente:</p>
<ul>
<li><p class="first">El método <em>getBlock</em>. Podemos ver cómo realizar una busqueda de un registro
filtrando por una condición espacial:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">{</span>
  <span class="n">String</span> <span class="n">attrGeomName</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="na">getDefaultFeatureType</span><span class="o">().</span><span class="na">getDefaultGeometryAttributeName</span><span class="o">();</span>
  <span class="n">FeatureQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="na">createFeatureQuery</span><span class="o">();</span>
  <span class="n">query</span><span class="o">.</span><span class="na">setFilter</span><span class="o">(</span> <span class="k">new</span> <span class="n">IntersectsEvaluator</span><span class="o">(</span><span class="n">attrGeomName</span><span class="o">,</span><span class="n">point</span><span class="o">)</span> <span class="o">);</span>
  <span class="n">set</span> <span class="o">=</span> <span class="n">blocks</span><span class="o">.</span><span class="na">getFeatureSet</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>
  <span class="k">if</span><span class="o">(</span> <span class="n">set</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">it</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">fastiterator</span><span class="o">();</span>
  <span class="n">Feature</span> <span class="n">f</span> <span class="o">=</span> <span class="o">(</span><span class="n">Feature</span><span class="o">)</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
  <span class="n">LandregistryviewerBlock</span> <span class="n">block</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultLandregistryviewerBlock</span><span class="o">(</span><span class="k">this</span><span class="o">,</span><span class="n">f</span><span class="o">.</span><span class="na">getGeometry</span><span class="o">(</span><span class="n">attrGeomName</span><span class="o">));</span>
  <span class="k">return</span> <span class="n">block</span><span class="o">;</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">DataException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
  <span class="k">if</span><span class="o">(</span> <span class="n">it</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span> <span class="o">{</span>
    <span class="n">it</span><span class="o">.</span><span class="na">dispose</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="k">if</span><span class="o">(</span> <span class="n">set</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span> <span class="o">{</span>
    <span class="n">set</span><span class="o">.</span><span class="na">dispose</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Puede encontrar información sobre los mecanismos
disponibles para el acceso a datos consultando la
<a class="reference external" href="https://gvsig.org/web/reference_catalog/lookupObject?uuid=b676641c65b75fd97c3f1cedb8482073">Guía para el desarrollador de la Librería de Acceso a Datos (DAL)</a></p>
</div>
<p>De aquí resaltar:</p>
<ul class="simple">
<li>Podemos averiguar qué atributo de la <em>feature</em> es el que contiene la geometría
a través del <em>getDefaultGeometryAttributeName</em> del <em>feature type</em> de nuestro <em>store</em>.</li>
<li>Para realizar una búsqueda de <em>features</em> en un <em>store</em> lo haremos invocando al método
<em>getFeatureSet</em> pasando como parámetro una instancia de <em>FeatureQuery</em> en la que se
especifiquen las condiciones de filtrado. En ella también se pueden especificar
orden o atributos que queremos recuperar en nuestra query.</li>
<li>La condición de filtro se especifica suministrando un Evaluator al método <em>setFilter</em>
de nuestra query.</li>
<li>Debemos encargarnos de liberar los objetos que creemos, como son <em>iteradores</em> o <em>feature sets</em>.
Hay que tener en cuenta que dependiendo del tipo de <em>store</em> con el que estemos trabajando
estos pueden tener reservados recursos como conexiones a BBDD, recordsets o conexiones a
servidores remotos.</li>
</ul>
</li>
<li><p class="first">El método <em>openShape</em>. Aquí podemos ver cómo abrir un <em>store</em> basado en shapes
ya existentes:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">parameters</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="na">createStoreParameters</span><span class="o">(</span><span class="s">&quot;Shape&quot;</span><span class="o">);</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setDynValue</span><span class="o">(</span><span class="s">&quot;shpfile&quot;</span><span class="o">,</span> <span class="n">shape</span><span class="o">);</span>
<span class="n">parameters</span><span class="o">.</span><span class="na">setDynValue</span><span class="o">(</span><span class="s">&quot;crs&quot;</span><span class="o">,</span> <span class="s">&quot;EPSG:23030&quot;</span><span class="o">);</span>
<span class="k">return</span> <span class="o">(</span><span class="n">FeatureStore</span><span class="o">)</span> <span class="n">manager</span><span class="o">.</span><span class="na">openStore</span><span class="o">(</span><span class="s">&quot;Shape&quot;</span><span class="o">,</span> <span class="n">parameters</span><span class="o">);</span>
</pre></div>
</div>
<p>Observaremos que para abrir un <em>store</em> lo realizaremos en dos fases. Por un lado crearemos
una estructura para albergar los parámetros necesarios para abrir nuestro <em>store</em>, la
inicializaremos con los valores adecuados e invocaremos al método <em>openStore</em> del manager
de acceso a datos con esos parámetros.</p>
<p>Cada tipo de <em>store</em> tendrá un juego de parámetros específicos de él. Para abrir un shape,
deberemos indicarle como mínimo el nombre del fichero y el sistema de referencia en el que
se encuentra.</p>
</li>
</ul>
</li>
<li><p class="first"><strong>IntersectsEvaluator</strong>. Se trata de la clase que evalúa la condición usada en el filtro.
Esta clase comprueba si el campo geometría especificado de una feature dada intersecta con
una geometría concreta. En su construcción se le suministran el campo que contiene la
geometría de la feature y la geometría con la que hay que comprobar si intersecta. De esta
clase conviene resaltar:</p>
<ul>
<li><p class="first">el método <em>evaluate</em>, encargado de realizar la comprobación:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">Geometry</span> <span class="n">op1geom</span> <span class="o">=</span> <span class="o">(</span><span class="n">Geometry</span><span class="o">)</span> <span class="n">data</span><span class="o">.</span><span class="na">getDataValue</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">op2attrname</span><span class="o">);</span>
<span class="k">return</span> <span class="k">new</span> <span class="n">Boolean</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">op1geom</span><span class="o">.</span><span class="na">intersects</span><span class="o">(</span><span class="n">op1geom</span><span class="o">));</span>
</pre></div>
</div>
<p>Sabiendo cómo se llama el atributo que contiene la geometría podemos obtener esta
a través del método <em>getDataValue</em>. Una vez tenemos las dos geometrías podemos
invocar el método <em>intersecs</em> de la geometría para comprobar si intersectan.</p>
</li>
<li><p class="first">El método <em>getCQL</em>. Este método devolverá una cadena siguiendo el formato de un <em>where</em> de
sql a utilizar como filtro en <em>stores</em> que ataquen a la BBDD sql. El filtro devuelto puede
no ser exactamente el mismo que el implementado por el código del método <em>evaluate</em>, actuando
a modo de filtro previo a este siempre que el store lo soporte.</p>
</li>
</ul>
</li>
<li><p class="first"><strong>DefaultLandregistryviewerBlock</strong>. Representa a una manzana de nuestro dominio. Almacena la
geometría que da forma a la manzana. La parte más relevante de esta clase es el
método <em>getProperties</em> que retorna todas las parcelas que se encuentran sobre
esa manzana:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">List</span> <span class="n">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>

<span class="n">FeatureStore</span> <span class="n">store</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">manager</span><span class="o">.</span><span class="na">getProperties</span><span class="o">();</span>
<span class="n">String</span> <span class="n">attrGeomName</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getDefaultFeatureType</span><span class="o">().</span><span class="na">getDefaultGeometryAttributeName</span><span class="o">();</span>
<span class="n">FeatureQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">createFeatureQuery</span><span class="o">();</span>
<span class="n">query</span><span class="o">.</span><span class="na">setFilter</span><span class="o">(</span> <span class="k">new</span> <span class="n">IntersectsEvaluator</span><span class="o">(</span><span class="n">attrGeomName</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">shape</span><span class="o">)</span> <span class="o">);</span>
<span class="n">set</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">manager</span><span class="o">.</span><span class="na">getProperties</span><span class="o">().</span><span class="na">getFeatureSet</span><span class="o">(</span><span class="n">query</span><span class="o">);</span>
<span class="k">if</span><span class="o">(</span> <span class="n">set</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">it</span> <span class="o">=</span> <span class="n">set</span><span class="o">.</span><span class="na">fastiterator</span><span class="o">();</span>
<span class="k">while</span><span class="o">(</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
  <span class="n">Feature</span> <span class="n">f</span> <span class="o">=</span> <span class="o">(</span><span class="n">Feature</span><span class="o">)</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
  <span class="n">LandregistryviewerProperty</span> <span class="n">property</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultLandregistryviewerProperty</span><span class="o">(</span>
    <span class="k">this</span><span class="o">.</span><span class="na">manager</span><span class="o">,</span>
    <span class="n">f</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="n">PROPERTIES_CODE</span><span class="o">),</span>
    <span class="n">f</span><span class="o">.</span><span class="na">getGeometry</span><span class="o">(</span><span class="n">attrGeomName</span><span class="o">),</span>
    <span class="n">f</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">PROPERTIES_CREATIONDATE</span><span class="o">),</span>
    <span class="n">f</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">PROPERTIES_MUNICODE</span><span class="o">)</span>
  <span class="o">);</span>
  <span class="n">properties</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">property</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">properties</span><span class="o">;</span>
</pre></div>
</div>
<p>Podemos observar que utiliza el mismo mecanismo para filtrar las parcelas que
usa el manager para recuperar un manzana. En este caso una vez a conseguido el <em>set</em>
con las parcelas, lo recorre, recuperando los datos de estas y creando los
objetos parcela.</p>
</li>
<li><p class="first"><strong>DefaultLandregistryviewerProperty</strong>. Se trata de la clase que representa a un parcela. En nuestro
ejemplo no tiene apenas lógica, limitándose a almacenar los datos y exponerlos mediante
<em>geters</em>.</p>
</li>
</ul>
</div>
<div class="section" id="la-libreria-con-la-presentacion">
<h2>5.7. La librería con la presentación<a class="headerlink" href="#la-libreria-con-la-presentacion" title="Permalink to this headline">¶</a></h2>
<p>Al igual que sucedía con la parte de la lógica, la presentación también estará dividida en
dos proyectos, por un lado el API y por otro la implementación.</p>
<ul class="simple">
<li>org.gvsig.Landregistryviewer.swing.api</li>
<li>org.gvsig.Landregistryviewer.swing.impl</li>
</ul>
<p>De forma similar a como sucedía con la lógica en la presentación, en el proyecto del
API sólo tenemos los interfaces y clases abstractas que definen nuestro API. El API
de la parte de presentación está formado por el interface del <em>manager</em> junto con
una serie de clases abstractas que definen el API público de nuestros componentes,
generalmente componentes que extenderán al componente de swing JPanel. Son clases
abstractas y no interfaces debido a que swing no presenta un modelo de interfaces
para sus componentes. En nuestro ejemplo, el único componente que tendremos es el
componente visual asociado a una manzana, el <em>JLandregistryviewerBlockPanel</em>,que extiende de
<em>JPanel</em> añadiéndole a nivel de API un único método que nos permita obtener el
componente lógico <em>LandregistryviewerBlock</em> que tiene asociado en un momento dado.</p>
<p>En la parte de implementación nos encontraremos con la clase <em>DefaultJLandregistryviewerBlockPanel</em>
que recibe en su constructor la instancia de <em>LandregistryviewerBlock</em> de la que debe presentar
sus datos. En general la parte de presentación no tiene una complicación mas allá
de la propia que pueda tener el manejo de swing. Lo único a resaltar
es que la parte de presentación no debería usar nada que no este expuesto en el API
de nuestra librería de lógica.
View source document</p>
</div>
<div class="section" id="integrandolo-con-gvsig">
<h2>5.8. Integrándolo con gvSIG<a class="headerlink" href="#integrandolo-con-gvsig" title="Permalink to this headline">¶</a></h2>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">Documento en construcion, pendiente de actualizar a 2,2.</p>
</div>
<p>Hasta ahora hemos visto cómo crear nuestros componentes, lógica e interface de usuario, usando
las librerías de gvSIG para acceder a los datos geográficos o para presentarlos, así como una
forma simple de crear una pequeña aplicación que los utilice. Vamos a ver ahora como integraríamos
esas funcionalidades en la aplicación gvSIG.</p>
<p>Si observamos los proyectos que tenemos en nuestro workspace veremos que aun hay uno sobre el que
no hemos trabajado, <strong>org.gvsig.visor.app.mainplugin</strong> . Es aquí donde está implementado nuestro
plugin. Antes de ver el código del plugin comentar un detalle. Cuando describíamos lo que tenía
que hacer nuestro plugin, dijimos que debía presentar un <em>splash</em> personalizado. Veamos primero
como podemos hacer esto.</p>
<p>En la carpeta <em>&#8220;src/main/resources&#8221;</em> encontraremos una carpeta <em>theme</em>, y dentro de esta un
fichero <em>andami-theme.xml</em>. Este fichero es el encargado de especificar al framework de andami
que <em>splash</em> se debe presentar así como si hay que utilizar alguna imagen de fondo en el MDI
de la aplicación o los iconos de las ventanas de gvSIG. Andami, al arrancar, buscará en las
carpetas de los plugins uno que tenga la carpeta <em>theme</em> y dentro este fichero y cuando
encuentre uno lo utilizará. El fichero xml de nuestro ejemplo contiene:</p>
<div class="highlight-xml"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>Por defecto las rutas que aparezcan en el fichero se interpretarán relativas a
la ubicación de este fichero, disponiendo de una variable <em>GVSIG_INSTALL</em> que
apuntará a la carpeta en la que está instalado gvSIG. En el ejemplo podemos
ver como en el tag <em>Splash</em> no se indica ruta para el fichero <em>&#8220;splash.png&#8221;</em>,
usándose el fichero que hay en la carpeta del plugin mientras que en el tag
<em>Icon</em> se usa la variable <em>GVSIG_INSTALL</em> para hacer referencia al fichero
que hay en el tema por defecto de Andami.</p>
<p>Podemos arrancar gvSIG y comprobar que sale el <em>splash</em> indicado en
nuestro fichero <em>andami-theme.xml</em>.</p>
<p>Una vez visto como podemos cambiar el <em>splash</em>, podemos echar un vistazo a la
extensión de nuestro plugin.</p>
<p>Vamos ahora a ver el código de nuestro <em>plugin</em>. Veremos que solo existen
dos clases, <em>VisorExtension</em> y PropertiesOfBlockListener. La clase que integra nuestra funcionalidad
en gvSIG es <em>VisorExtension</em>. Esta clase extiende la clase <em>Extension</em> de <em>Andami</em>
para integrarse con los menús y barras de herramientas, así como implementa
el interface <em>ExclusiveUIExtension</em>, para controlar la visibilidad de otras extensiones de
gvSIG.</p>
<p>Para controlar la visibilidad de las otras extensiones de gvSIG, el interface
<em>ExclusiveUIExtension</em> aporta los métodos:</p>
<ul>
<li><p class="first"><strong>isEnabled</strong> recibiendo como parametro la extensión sobre la que se
quiere averiguar si debe estar habilitada o no:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEnabled</span><span class="o">(</span><span class="n">IExtension</span> <span class="n">extension</span><span class="o">)</span>
</pre></div>
</div>
<p>En nuestro caso, como lo que queremos es deshabilitar todas las extensiones
de edición, comprobaremos si la extensión que nos llega está en el paquete
java <em>&#8220;org.gvsig.editing&#8221;</em> y para todas las que se encuentren en ese paquete
devolveremos <em>false</em>, mientras que para el resto, delegaremos en ellas para
averiguar si deben o no estar habilitadas.</p>
</li>
<li><p class="first"><strong>isVisible</strong> recibiendo como parametro la extensión sobre la que se
quiere averiguar si debe estar visible o no:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isVisible</span><span class="o">(</span><span class="n">IExtension</span> <span class="n">extension</span><span class="o">)</span>
</pre></div>
</div>
<p>En nuestro caso, utilizaremos para determinar qué extensiones deben estar visibles
el mismo que usamos para determinar si deben estar deshabilitadas.</p>
</li>
</ul>
<p>Es muy importante delegar en los métodos <em>isEnabled</em> o <em>isVisible</em> de cada extensión
y no devolver <em>true</em> ya que puede que la extensión precise de algunas condiciones específicas
para estar visible o activa que ella misma comprueba.</p>
<p>Los métodos que nos encontramos en nuestra clase <em>VisorExtension</em> que precisa por extender
a <em>Extension</em> son:</p>
<ul>
<li><p class="first"><strong>initialize</strong>. Se invoca al cargar la extensión. Aquí nos limitaremos a registrar
servicios que ofrezca nuestra extensión. En nuestro caso nos limitaremos a informar al
<em>manager</em> de <em>plugins</em> que nuestra clase visor quiere actuar como controladora de la
visibilidad de todas las extensiones. Esto lo haremos a través del método
<em>setExclusiveUIExtension</em> :</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">PluginsManager</span> <span class="n">manager</span> <span class="o">=</span> <span class="n">PluginsLocator</span><span class="o">.</span><span class="na">getManager</span><span class="o">();</span>
<span class="n">manager</span><span class="o">.</span><span class="na">setExclusiveUIExtension</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>postInitialize</strong>. Se invoca durante la inicialización de los plugins, una vez invocado
al método <em>initialize</em> de todas las extensiones. Esto nos garantiza que cuando se ejecuta
estarán disponinles prácticamente todos los servicios de gvSIG. Aprovecharemos este método
para:</p>
<ul>
<li><p class="first">Añadir nuestra información al <em>acerca de gvSIG</em>, esto lo haremos a través de nuestra
función <em>addToAbout</em>. El código que lo realiza es:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">AboutManager</span> <span class="n">about</span> <span class="o">=</span> <span class="n">AboutLocator</span><span class="o">.</span><span class="na">getManager</span><span class="o">();</span>

<span class="n">URL</span> <span class="n">description</span> <span class="o">=</span> <span class="n">getResourceURL</span><span class="o">(</span><span class="s">&quot;about/description.html&quot;</span><span class="o">);</span>
<span class="n">URL</span> <span class="n">icon</span> <span class="o">=</span> <span class="n">getResourceURL</span><span class="o">(</span><span class="s">&quot;about/icon.png&quot;</span><span class="o">);</span>
<span class="n">AboutParticipant</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">about</span><span class="o">.</span><span class="na">addDeveloper</span><span class="o">(</span><span class="s">&quot;Mi empresa&quot;</span><span class="o">,</span> <span class="n">description</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">icon</span><span class="o">);</span>
<span class="n">dev</span><span class="o">.</span><span class="na">addContribution</span><span class="o">(</span><span class="s">&quot;Mi visor&quot;</span><span class="o">,</span> <span class="s">&quot;Visor para consulta de parcelas catastrales&quot;</span><span class="o">,</span> <span class="mi">2011</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2011</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</pre></div>
</div>
<p>Cuando vamos a añadir nuestra información al <em>&#8220;acerca de&#8221;</em>, tendremos que hacer dos
cosas:</p>
<ul>
<li><p class="first">Añadir una entrada como desarrolladores con nuestra información. Deberemos
proporcionar el nombre de nuestra empresa y una descripción de esta mediante
la URL a un documento en HTML. Normalmente este documento formará parte
de los recursos de nuestro proyecto.</p>
<p>Si dos extensiones intentan añadir más de una vez como desarrollador a empresas
con el mismo nombre sólo será añadida la primera.</p>
</li>
<li><p class="first">Añadiremos a nuestra empresa información sobre el desarrollo que hemos hecho, un
nombre y una pequeña descripción.</p>
</li>
</ul>
<p>Normalmente cada plugin que realicemos registrará la empresa, como la información del
desarrollo en concreto de ese plugin.</p>
</li>
<li><p class="first">Crear el manager de la parte de lógica de nuestra librería.</p>
</li>
<li><p class="first">Inicializar los <em>stores</em> a través de nuestra función <em>initializeStores</em>. Como el manager de nuestra
librería de lógica disponía de métodos para inicializar los <em>stores</em> nos limitaremos a
invocarlos:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">manager</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span>
  <span class="n">getResource</span><span class="o">(</span><span class="s">&quot;data/properties.shp&quot;</span><span class="o">),</span>
  <span class="n">getResource</span><span class="o">(</span><span class="s">&quot;data/blocks.shp&quot;</span><span class="o">)</span>
<span class="o">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Y por último crear y mostrar la venta con nuestra vista, a través del método <em>createViewWindow</em>.
vamos a ver con un poco más de detalle cómo se realiza esto. Antes de empezar
lo primero que haremos será obtener una referencia del objeto <em>aplicacion</em> y del
manager de <em>proyectos</em>:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">ApplicationManager</span> <span class="n">application</span> <span class="o">=</span> <span class="n">ApplicationLocator</span><span class="o">.</span><span class="na">getManager</span><span class="o">();</span>
<span class="n">ProjectManager</span> <span class="n">projectManager</span> <span class="o">=</span> <span class="n">application</span><span class="o">.</span><span class="na">getProjectManager</span><span class="o">();</span>
</pre></div>
</div>
<p>Una vez disponemos de estas referencias, podemos crear nuestra vista:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// 1. Create a new view and set the name.</span>
<span class="n">ViewManager</span> <span class="n">viewManager</span> <span class="o">=</span> <span class="o">(</span><span class="n">ViewManager</span><span class="o">)</span> <span class="n">projectManager</span><span class="o">.</span><span class="na">getDocumentManagers</span><span class="o">(</span><span class="n">ViewManager</span><span class="o">.</span><span class="na">TYPENAME</span><span class="o">);</span>
<span class="n">ViewDocument</span> <span class="n">view</span> <span class="o">=</span> <span class="o">(</span><span class="n">ViewDocument</span><span class="o">)</span> <span class="n">viewManager</span><span class="o">.</span><span class="na">createDocument</span><span class="o">();</span>
<span class="n">view</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">MY_VIEW_NAME</span><span class="o">);</span>
</pre></div>
</div>
<p>Para crear la vista, pediremos al <em>ProjectManager</em> que nos devuelva el manager de vistas, y a
este le pediremos una nueva instancia del documento vista. Debemos recordar aquí,
que una de las principales
funcionalidades de los <em>manager</em> es actuar a modo de factorías para obtener instancias de los
objetos que gestiona ese <em>manager</em>. Una vez disponemos del documento vista, le asignaremos el
nombre que nosotros consideremos oportuno.</p>
<p>Con la vista ya creada, procederemos a ver cómo hemos de hacer para añadir a esta las capas que
necesitemos. Para ello crearemos una capa con las manzamas, esto lo realizaremos a través
del método <em>createLayer</em>, indicándole el nombre de la capa y el <em>store</em> en que queremos que
se base:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// 2. Create a new layer with the blocks</span>
<span class="n">FLyrVect</span> <span class="n">layer</span> <span class="o">=</span> <span class="o">(</span><span class="n">FLyrVect</span><span class="o">)</span> <span class="n">application</span><span class="o">.</span><span class="na">getMapContextManager</span><span class="o">().</span><span class="na">createLayer</span><span class="o">(</span><span class="s">&quot;Blocks&quot;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">manager</span><span class="o">.</span><span class="na">getBlocks</span><span class="o">());</span>
</pre></div>
</div>
<p>Con la capa ya creada, añadiremos al <em>mapa</em> de la vista la nueva capa:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// 3. Add this layer to the mapcontext of the new view.</span>
<span class="n">view</span><span class="o">.</span><span class="na">getMapContext</span><span class="o">().</span><span class="na">getLayers</span><span class="o">().</span><span class="na">addLayer</span><span class="o">(</span><span class="n">layer</span><span class="o">);</span>
</pre></div>
</div>
<p>Añadiremos al proyecto corriente la vista:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// 4. Add the view to the current project.</span>
<span class="n">projectManager</span><span class="o">.</span><span class="na">getCurrentProject</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">view</span><span class="o">);</span>
</pre></div>
</div>
<p>Y por último nos encargaremos de presentar la ventana asocida a la vista que
acabamos de crear:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// 5. Force to show the view&#39;s window.</span>
<span class="n">IView</span> <span class="n">viewWindow</span> <span class="o">=</span> <span class="o">(</span><span class="n">IView</span><span class="o">)</span> <span class="n">viewManager</span><span class="o">.</span><span class="na">getMainWindow</span><span class="o">(</span><span class="n">view</span><span class="o">);</span>

<span class="n">application</span><span class="o">.</span><span class="na">getUIManager</span><span class="o">().</span><span class="na">addWindow</span><span class="o">(</span><span class="n">viewWindow</span><span class="o">,</span> <span class="n">GridBagConstraints</span><span class="o">.</span><span class="na">CENTER</span><span class="o">);</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="n">application</span><span class="o">.</span><span class="na">getUIManager</span><span class="o">().</span><span class="na">setMaximum</span><span class="o">((</span><span class="n">IWindow</span><span class="o">)</span> <span class="n">viewWindow</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">PropertyVetoException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;Can&#39;t maximize view.&quot;</span><span class="o">,</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Una vez ya tenemos mostrada nuestra ventana de la vista, precisaremos registrar en el
componente gráfico del mapa la nueva herramienta que aportamos, de forma similar a
como hicimos para añadirla a nuestro mapa en el proyecto de pruebas:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// 6. Register my tool in the mapcontrol of the view.</span>
<span class="n">PropertiesOfBlockListener</span> <span class="n">listener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PropertiesOfBlockListener</span><span class="o">();</span>
<span class="n">viewWindow</span><span class="o">.</span><span class="na">getMapControl</span><span class="o">().</span><span class="na">addBehavior</span><span class="o">(</span><span class="n">TOOL_NAME</span><span class="o">,</span> <span class="k">new</span> <span class="n">PointBehavior</span><span class="o">(</span><span class="n">listener</span><span class="o">));</span>
</pre></div>
</div>
</li>
</ul>
<p>Con todo esto tendremos inicializado nuestro plugin.</p>
</li>
<li><p class="first"><em>execute</em>. Este metodo será invocado cada vez que el usuario interactue con las opciones
de menú o botones que se configuraron en el fichero <em>config.xml</em> de nuestro plugin.
En nuestro caso, se configuró para que se dispare este evento cuando el usuario
quisiese activar la herramienta de información sobre parcelas catastrales de
una manzana. Así que el código que tendríamos que tener ahí debe corresponderse
con esto:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="k">if</span><span class="o">(</span> <span class="n">ACTION_SETINFOTOOL</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">actionCommand</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Set the tool in the mapcontrol of the active view.</span>
  <span class="n">ApplicationManager</span> <span class="n">application</span> <span class="o">=</span> <span class="n">ApplicationLocator</span><span class="o">.</span><span class="na">getManager</span><span class="o">();</span>
  <span class="k">if</span><span class="o">(</span> <span class="n">application</span><span class="o">.</span><span class="na">getActiveWindow</span><span class="o">()</span> <span class="o">!=</span> <span class="n">viewWindow</span> <span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="n">viewWindow</span><span class="o">.</span><span class="na">getMapControl</span><span class="o">().</span><span class="na">setTool</span><span class="o">(</span><span class="n">TOOL_NAME</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Observaremos que lo primero que hacemos es comprobar si el comando que recibimos
es el correspondiente a la activación de nuestra herramienta, y que fijamos
en el <em>config.xml</em>. Esto es debido a que en una misma extensión podemos
agrupar varias herramientas, indicando nombres de comando distintos en el
<em>config.xml</em> para cada una de ellas.</p>
<p>Una vez sabemos que se está tratando de activar nuestra herramienta de información,
comprobaremos si está activa la ventana de nuestra vista, ya que sobre otras vistas u
otros tipos de documento, no debemos hacer nada. Y por último, nos dedicaremos
a activar nuestra herramienta en el mapa de la vista. Herramenta que habíamos registrado
en el <em>postInitialize</em> de nuestra extensión.</p>
</li>
<li><p class="first"><em>isVisible</em>. En este método deberemos informar si los menús y botones asociados a nuestra
herramienta deben estar visibles. En nuestro caso dejaremos visible nuestra herramienta
siempre que la ventana activa sea la de nuestra vista:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="n">ApplicationManager</span> <span class="n">application</span> <span class="o">=</span> <span class="n">ApplicationLocator</span><span class="o">.</span><span class="na">getManager</span><span class="o">();</span>
<span class="k">return</span> <span class="n">application</span><span class="o">.</span><span class="na">getActiveWindow</span><span class="o">()</span> <span class="o">==</span> <span class="n">viewWindow</span><span class="o">;</span>
</pre></div>
</div>
</li>
<li><p class="first"><em>isEnabled</em>, que devolveremos siempre &#8216;true&#8217;, ya que nuestra herramienta estará activa
siempre que esté visible, y allí ya pusimos las comprobaciones necesarias. Si la
logica de nuestra herramienta permite que no esté activa en algunos casos para
los que sí se permite que esté visible, será aquí donde deberemos realizar esas comprobaciones.</p>
</li>
</ul>
<p>Básicamente, hemos repasado como sería la integración de nuestra funcionalidad en gvSIG.
Nos queda por ver la clase <em>PropertiesOfBlockListener</em> que usamos para crear nuestra
herramienta. El código del <em>listener</em> es básicamente similar al empleado por nuestra
aplicación de pruebas.</p>
</div>
<div class="section" id="distribuyendo-nuestro-proyecto">
<h2>5.9. Distribuyendo nuestro proyecto<a class="headerlink" href="#distribuyendo-nuestro-proyecto" title="Permalink to this headline">¶</a></h2>
<p>Una vez, tenemos nuestro desarrollo desplegado sobre un gvSIG podemos ejecutar ese
gvSIG y comprobar si funciona correctamente. Ahora bien, normalmente nuestro trabajo
no termina ahí. Lo normal es que tengamos que hacer llegar esos plugins a nuestros
usuarios, o incluso antes a testers que verifiquen que todo funciona correctamente.</p>
<p>Con la versión 2.0 de gvSIG se desarrolló un sistema de paquetes que nos permiten
distribuir plugins de forma que los usuarios puedan instalarlos fácilmente desde
el <em>administrador de complementos</em> de gvSIG.</p>
<p>Cada vez que compilamos nuestro proyecto usando <em>&#8220;mvn install&#8221;</em>, además de compilarlo
se realizan algunas funciones mas. Las que nos interesan ahora mismo son:</p>
<ul class="simple">
<li>Los plugins de gvSIG de este se despliegan e instalan en la
instalación de gvSIG con la que estamos trabajando de forma que con solo arrancar
gvSIG observamos que estos ya están funcionales.</li>
<li>Además de desplegar e instalar nuestros plugins, se dejan los paquetes de estos
en la carpeta &#8220;install&#8221; de la instalación de gvSIG.</li>
</ul>
<p>El paquete de instalación generado podemos distribuirlo directamente a nuestros usuarios
o hacerlo llegar al proyecto gvSIG para que se exponga en el repositorio de complementos de gvSIG
y esté disponible a los usuarios directamente desde el <em>Administrador de complementos</em> a través
de la URL que muestra por defecto.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Puede consultar el articulo <a class="reference external" href="http://blog.gvsig.org/2015/09/04/crea-tu-propio-gvsig-nuevo-plugin/">Crea tu propio gvSIG</a>
del blog de gvSIG para leer más sobre ello.</p>
</div>
<p>Así mismo, podríamos generar una distribución personalizada de gvSIG desktop que incluyese
una selección de los plugins <em>standard</em> junto con nuestros plugins de forma que podamos disponer
de un instalable personalizado con nuestros plugins para entregar a nuestros clientes.</p>
<p>View source document</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="conclusions.html" title="6. Conclusiones"
             >next</a> |</li>
        <li class="right" >
          <a href="build_tools.html" title="4. Herramientas de construcción"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">gvSIG Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Documentación de gvSIG (ES)</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, gvSIG Association.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>